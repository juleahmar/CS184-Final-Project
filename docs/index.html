<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Jule Ahmar, CS184-abr</h2>

<br><br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/colorWheelMess.png" align="middle" width="400px"/>
      </td>
    </tr>
  </table>
</div>

<div>

<h2 align="middle">Overview</h2>
<p>This project consisted of exploring the basic methods used in rasterization and texture mapping. In the first part, I explored the different results that came from sampling once per pixel vs supersampling. Supersampling helps us with antialiasing, in order to get a smoother image overall. Then, I was able to play around with different matrix transformations using homogenous coordinates, and see their effects on the screen (via changing the orientation of body parts of a robot man). Next, barycentric coordinates were introduced, and I used them to interpolate between color values to determine the color at a certain pixel. Finally, I explored texture mapping and a couple of varying methods that are commonly used when going from a 3D object to points on a texture map. Using UV coordinates, certain points on our 3D models were mapped to a point on a texture map to create the final image. Again, different methods were tested, and the results are shown below.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>The main idea behind rasterization is checking whether certain points in a pixel land inside or outside of a given triangle that we are trying to draw. In this very first part of the project, we just check one point (the center of the pixel), and assign that pixel a color based on if it is inside or outside of the triangle. So we iterate through each pixel in the bounding box of the triangle and calculate the position of the center of that pixel, and pass that into our function that checks if a point is inside a triangle. The main issues I ran into in this part were related to storing values in the correct data types. For example, I originally used integers instead of floats at some places, which lead to funky and incorrect results when rasterizing the image.</p>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/1sample.png" align="middle" width="400px"/>
        <figcaption align="middle">This image shows how pixels are either fully colored in red or they are left blank on a skinny triangle edge.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>
<p> In order to implement supersampling, we now sample multiple times per pixel (hence the name), instead of just at its center. To do this, I created indexing variables sub-column and sub-row in order to keep track of our place in the pixel. We can then break the original pixel down into smaller 'sub-pixels', and check if these sample points are inside or outside of the triangle we are trying to draw. Next, when we color the pixel, instead of coloring it either completely red or white, for example, we can take an average over all of the colors of the points we sampled. This helps us get rid of 'jaggies', and makes for a smoother image overall. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/1sample.png" align="middle" width="400px"/>
        <figcaption align="middle">The same 1-sample-per-pixel image as above. Jaggies are obvious.</figcaption>
      </td>
      <td>
        <img src="pics/4sample.png" align="middle" width="400px"/>
        <figcaption align="middle">4 samples per pixel. Taking multiple samples helps blur the edges' sharpness.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="pics/9sample.png" align="middle" width="400px"/>
        <figcaption align="middle">9 samples per pixel. Looking better.</figcaption>
      </td>
      <td>
        <img src="pics/16sample.png" align="middle" width="400px"/>
        <figcaption align="middle">16 samples per pixel. A much smoother image overall.</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>As the images above show, taking more samples per image clearly helps reduce the aliasing effects.</p>

<h3 align="middle">Part 3: Transforms</h3>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/jumpingJackRobot.png" align="middle" width="400px"/>
        <figcaption align="middle">I made my robot do a jumping jack! In order to achieve this positioning, I first translated up then rotated the ends of the arms, then simply rotated each of the legs outwards.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
<p>The Barycentric coodrinate system is one that allows us to describe the location of a point relative to the vertices of the triangle. Barycentric coordinates are extremely useful when doing interpolation between values, whether they be colors or textures. They have very useful applications in general.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/barycentric.png" align="middle" width="400px"/>
        <figcaption align="middle">This image from an online source gives a visual representation of value interpolation using barycentric coordinates.</figcaption>
      </td>
    </tr>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/colorWheel.png" align="middle" width="400px"/>
        <figcaption align="middle">This is the color wheel created from svg/basic/test7.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<p>In part 5, we used barycentric coordinates to find the correct mapping from image to texture space. We used two separate sampling methods when trying to compute this mapping: nearest neighbor and bilinear. Nearest neighbor is as simple as it sounds, go to the texel nearest to your point in the texel space, and take its value. Bilinear sampling is a little bit more costly, as it finds the four nearest neighbors, and interpolates their values. However, since bilinear sampling will end up with a more accurate color to fill your pixel with, it results in a smoother image than nearest neighbor sampling, which is shown by the images below. In this part, the most diffult aspect for me was fully understanding the full graphics pipeline, and how different functions worked together. Understanding this made implementing the different sampling methods easier. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/nearest1.png" align="middle" width="400px"/>
        <figcaption align="middle">Using nearest pixel sampling, 1 sample per pixel.</figcaption>
      </td>
      <td>
        <img src="pics/nearest16.png" align="middle" width="400px"/>
        <figcaption align="middle">Using nearest pixel sampling, 16 samples per pixel.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="pics/bilinear1.png" align="middle" width="400px"/>
        <figcaption align="middle">Using bilinear sampling, 1 sample per pixel.</figcaption>
      </td>
      <td>
        <img src="pics/bilinear16.png" align="middle" width="400px"/>
        <figcaption align="middle">Using bilinear sampling, 16 samples per pixel.</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<p>When we do texture mapping, we may need to use different resolution versions of the original texture to complete our image on the screen space in the best looking way possible. For example, as we saw in lecture, things that are far away in the image should use downsampled versions of the texture. This is done to fix antialiasing, and get rid of effects such as jaggies and moire. However, things that are near the 'camera' should use the original, level 0 texture to keep the high resolution. As a result, we use different mipmap levels when applicable. Similar to in earlier parts, when we use bilinear sampling vs nearest point sampling, we will have to do more calculations, resulting in slower rasterization speed and a more costly program overall. However, it does result in a smoother image.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="pics/znear1.png" align="middle" width="400px"/>
        <figcaption align="middle">Zero level, nearest neighbor sampling.</figcaption>
      </td>
      <td>
        <img src="pics/zlin1.png" align="middle" width="400px"/>
        <figcaption align="middle">Zero level, bilinear sampling.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="pics/nearnear1.png" align="middle" width="400px"/>
        <figcaption align="middle">Nearest level, nearest neighbor sampling.</figcaption>
      </td>
      <td>
        <img src="pics/nearlin1.png" align="middle" width="400px"/>
        <figcaption align="middle">Nearest level, bilinear sampling.</figcaption>
      </td>
    </tr>
  </table


<h2 align="middle">Section III: Art Competition</h2>

<h3 align="middle">Part 7: Draw something interesting!</h3>



</body>
</html>
